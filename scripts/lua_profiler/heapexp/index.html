<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv='Content-type' content='text/html; charset=utf-8'>
    <title>LUA Heap Explorer</title>
  </head>
  <body>
    <input type="file" id="files" name="stuff" multiple=false style="width:500px;"/>    
    <div id="container">
    </div>
    <style>
    .fieldClass {
      display: inline-block;
      max-width: 1500px;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
      vertical-align: text-bottom;
    }

    </style>
    <script src="build/react.js"></script>
    <script src="build/JSXTransformer.js"></script>

    <script type="text/jsx;harmony=true">


class HeapPtr {
  constructor(low, hi) {
    this.low = low;
    this.hi = hi;
  }

  eq(otherPtr) {
    return otherPtr.low == this.low && otherPtr.hi == this.hi;
  }

  hsh() {
    return this.low + ':' + this.hi;
  }

  looksValid() {
    // Lua table data is completely (I think???) un-annotated, so best guess is to look
    // for something that couldn't possibly be a pointer to something.
    if ((this.low > 0 && this.low < 0x01000000) || this.low < 0 || this.hi > 0x00000010 || this.hi < 0) {
      return false;
    }
    return true;
  }
}

class HeapObject {
  constructor(selfPtr, allocStr) {
    this.selfPtr = selfPtr;
    this.allocStr = allocStr;
  }

  toString() {
    return '';
  }

  getArrayMapVals() {
    return [];
  }

  getFieldForPtr() {
    return null;
  }
}


class StringHeapObject extends HeapObject {
  constructor(selfPtr, allocStr, str) {
    super(selfPtr, allocStr);
    this.str = str;
  }

  toString() {
    return '"' + this.str + '"'; 
  }
}

class ClosureHeapObject extends HeapObject {
  constructor(selfPtr, allocStr, upVals) {
    super(selfPtr, allocStr);
    this.upVals = upVals;
  }

  toString() {
    return 'Closure@' + this.selfPtr;
  }
}

class TableHeapObject extends HeapObject {
  constructor(selfPtr, allocStr, metaTable, arrayPtr, nodePtr) {
    super(selfPtr, allocStr);
    this.metaTable = metaTable;
    this.arrayPtr = arrayPtr;
    this.nodePtr = nodePtr;
  }

  getArrayPtr() { return this.arrayPtr; }
  getNodePtr() { return this.nodePtr; }

  toString() {
    return 'Table@' + this.selfPtr;
  }
}

class ArrayHeapObject extends HeapObject {
  constructor(selfPtr, allocStr, entries, stringFieldNames) {
    super(selfPtr, allocStr);
    this.entries = entries;
    this.stringFieldNames = stringFieldNames;
  }

  getArrayMapVals() {
    return this.stringFieldNames;
  }

  getFieldForPtr(ptr) {

  }

  toString() {
    return 'ArrayMap@' + this.selfPtr;
  }
}

class UpValueHeapObject extends HeapObject {
  constructor(selfPtr, allocStr, valPtr) {
    super(selfPtr, allocStr);
    this.valPtr = valPtr;
  }

  toString() {
    return 'UpValue@' + this.selfPtr;
  }
}

class UserDataHeapObject extends HeapObject {
  constructor(selfPtr, allocStr, metaTable) {
    super(selfPtr, allocStr);
    this.metaTable = metaTable;
  }

  toString() {
    return 'UserData@' + this.selfPtr;
  }
}

class UnknownHeapObject extends HeapObject {
  constructor(selfPtr, allocStr, bytes) {
    super(selfPtr, allocStr);
    this.bytes = bytes;
  }
}

class ArrayReader {
  constructor(array, opt_offset) {
    this.array = array;
    this.offset = opt_offset || 0;
    this.view = new DataView(this.array);
  }

  nextU8() {
    var v = this.view.getUint8(this.offset);
    this.offset++;
    return v;
  }

  nextU32() {
    var v = this.view.getUint32(this.offset, true);
    this.offset += 4;
    return v;
  }

  nextPtr() {
    var v = new HeapPtr(this.view.getInt32(this.offset, true), this.view.getInt32(this.offset + 4, true));
    this.offset += 8;
    return v;
  }

  peekPtr() {
    return new HeapPtr(this.view.getInt32(this.offset, true), this.view.getInt32(this.offset + 4, true));    
  }

  peekByte(offset) {
    return this.view.getUint8(this.offset + offset);
  }

  skip(numBytes) {
    this.offset += numBytes;
  }

  readBytes(numBytes) {
    var v = new DataView(this.array, this.offset, numBytes);
    this.skip(numBytes);
    return v;
  }

  getOffset() {
    return this.offset;
  }

  nextStr() {
    var result = "";

    var c = this.nextU8();
    while (c != 0) {
      result += String.fromCharCode(c);
      c = this.nextU8();
    }

    return result;
  }
}

class HeapRow extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      expanded: false
    };

    this.allocStr = this.props.k;
    //this.ptr = this.props.
  }

  _onClickStr(e) {
    this.setState({
      expanded: !this.state.expanded
    });
  }

  _renderSub() {
  }

  _renderRoot() {
    var onClickStr = (e) => {this._onClickStr(e);};
    if (this.state.expanded) {
      var subRows = [];
      var allocs = this.props.idxToObjs[this.allocStr];

      for (var idx in allocs) {
        let alloc = allocs[idx];
        subRows.push(<HeapRow key={alloc.selfPtr} ptr={alloc.selfPtr} depth={this.props.depth + 1} root="false" k={alloc.allocStr} idxToObjs={this.props.idxToObjs} objs={this.props.objs} strsToIdx={this.props.strsToIdx} backMap={this.props.backMap} />);
      }

      return (
        <div>
          <div onClick={onClickStr}>{this.props.k}</div>
          {subRows}
        </div>
      );     
    }

    return (
      <div>
        <div onClick={onClickStr}>{this.props.k}</div>
      </div>
    ); 

  }

  _renderAlloc() {
    var onClickStr = (e) => {this._onClickStr(e);};
    var obj = this.props.objs[this.props.ptr];
    var arrMapVals = obj.getArrayMapVals();
    var arrMapStr = ''
    for (var v in arrMapVals) {
      arrMapStr += arrMapVals[v] + ', ';
    }

    if (this.state.expanded) {
      var subRows = [];
      var referers = this.props.backMap[this.props.ptr];

      for (var idx in referers) {
        let alloc = referers[idx];
        subRows.push(<HeapRow key={alloc.selfPtr} ptr={alloc.selfPtr} depth={this.props.depth + 1} root="false" k={alloc.allocStr} idxToObjs={this.props.idxToObjs} objs={this.props.objs} strsToIdx={this.props.strsToIdx} backMap={this.props.backMap} />);
      }
      return (
        <div>
          <div style={{display:'inline-block', paddingLeft: (16 * this.props.depth) +'px'}} onClick={onClickStr}>{this.props.k}</div><div style={{display:'inline-block'}}>{obj.toString()}</div><div className="fieldClass">{arrMapStr}</div>
          {subRows}
        </div>
      ); 
    }
    return (
      <div>
        <div style={{display:'inline-block', paddingLeft: (16 * this.props.depth) +'px'}} onClick={onClickStr}>{this.props.k}</div><div style={{display:'inline-block'}}>{obj.toString()}</div><div className="fieldClass">{arrMapStr}</div>
      </div>
    ); 
  }

  render() {
    if (this.props.root == 'true') {
      return this._renderRoot();
    } else {
      return this._renderAlloc();
    }
  }
}

class HeapRows extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    let rows = [];
    for (var key in this.props.diffStrsToIdx) {
      rows.push(<HeapRow root="true" depth={0} key={key} k={key} strs={this.props.strs} idxToObjs={this.props.idxToObjs} objs={this.props.objs} strsToIdx={this.props.strsToIdx} backMap={this.props.backMap} />);
    }

    return (
      <div>{rows}</div>
    );
  } 
}

class DiffHeap {
  constructor(a, b) {
    this.heapA = a;
    this.heapB = b;

    this.strs = [];
    this.strsToIdx = {};

    this.heapObjs = {};

    this.allocIdxToObjs = {};
    this.backMap = {};

    //this.strs = this._unionArr(a.strs, b.strs);
    this.strsToIdx = this._unionMap(a.strsToIdx, b.strsToIdx);
    this.heapObjs = this._unionMap(a.heapObjs, b.heapObjs);
    this.backMap = this._unionMap(a.backMap, b.backMap);

    this.diffObjs = this._subMap(this.heapObjs, b.heapObjs);
    this.diffStrsToIdx = {};
    for (var k in this.diffObjs) {
      let obj = this.diffObjs[k];
      this.diffStrsToIdx[obj.allocStr] = 1;


      let objList = this.allocIdxToObjs[obj.allocStr];
      if (!objList) {
        objList = [];
        this.allocIdxToObjs[obj.allocStr] = objList;
      }
      objList.push(obj);
    }
  }

  _subMap(m1, m2) {
    let result = {};

    for (var k1 in m1) {
      if (!m2[k1]) {
        result[k1] = m1[k1];
      }
    }

    return result;
  }

  _unionMap(m1, m2) {
    let result = {};

    for (var k in m1) {
      result[k] = m1[k];
    }
    for (var k in m1) {
      result[k] = m1[k];
    }
    return result;
  }

  _unionArr(arr1, arr2) {
    let result = [];
    let smallest = arr1.length > arr2.length ? arr2 : arr1;
    let largest = arr1.length <= arr2.length ? arr2 : arr1;
  
    let i = 0;
    for (i = 0; i < smallest.length; i++) {
      result.push(smallest[i]);
      console.assert(smallest[i] == largest[i]);
    }

    for (i; i < largest.length; i++) {
      result.push(largest[i]);
    }
    return result;
  }
}

class Heap {
  constructor(heapBytes) {
    this.strs = [];
    this.strsToIdx = {};

    this.heapObjs = {};
    this.unknownObjs = {};
    this.tableObjs = {};

    this.allocIdxToObjs = {};
    this.backMap = {};

    if (heapBytes) {
      var heapReader = new ArrayReader(heapBytes);

      this._processAllocLocationStrings(heapReader);
      this._processAllocs(heapReader);

      console.log('done processing!');
    }
  }

  diff(otherHeap) {
    return new DiffHeap(this, otherHeap);
  }

  _addToBackmap(ptr, obj) {
    var objList = this.backMap[ptr];

    if (!objList) {
      objList = [];
      this.backMap[ptr] = objList;
    }
    objList.push(obj);
  }

  _processAllocLocationStrings(reader) {
    let numStrs = reader.nextU32();
    for (var i = 0; i < numStrs; i++) {
      var s = reader.nextStr();
      this.strs.push(s);
      this.strsToIdx[s] = i;
    }
  }

  _processClosure(reader, ptr, allocStr) {
    let isCFunc = reader.nextU8();
    let numUpVals = reader.nextU8();

    if (isCFunc) {
      // Don't bother with C funcs, since I don't think they can
      // keep anything alive.  (They close on values, not pointers).
      reader.skip(4 + 8 + 8 + 8 + (numUpVals * 16));
      return new ClosureHeapObject(ptr, allocStr, []);
    }


    if (numUpVals == 0) {
      // No upvals means we aren't keeping anything leakable alive (I think!)
      reader.skip(4 + 8 + 8 + 8);
      return new ClosureHeapObject(ptr, allocStr, []);
    }
  
    // Padding.
    reader.nextU32();

    let gclist = reader.nextPtr();
    let env = reader.nextPtr();

    let proto = reader.nextPtr();
    let ptrs = [];
    let result = new ClosureHeapObject(ptr, allocStr, ptrs);
    for (var i = 0; i < numUpVals; i++) {
      var p = reader.nextPtr();
      ptrs.push(p);

      this._addToBackmap(p.low, result);
    }

    return result;
  }

  _processFuncPrototype(reader) {
    // Don't think prototypes can keep leakable stuff alive....
    // PADDING
    reader.nextU8();reader.nextU8();

    let constants = reader.nextPtr();

    // PADDING
    reader.nextU32();
    let code = reader.nextPtr();
    let proto = reader.nextPtr();
    let lineInfo = reader.nextPtr();
    let localVars = reader.nextPtr();
    let upvalNames = reader.nextPtr();
    let source = reader.nextPtr();

    let numUps = reader.nextU32();
    let numConstants = reader.nextU32();
    let codeSize = reader.nextU32();
    let lineInfSize = reader.nextU32();
    let protoSize = reader.nextU32();
    let lineDef = reader.nextU32();
    let lastLineDef = reader.nextU32();

    // PADDING
    reader.nextU32();

    let gclist = reader.nextPtr();

    let numUps2 = reader.nextU8();
    let numParams = reader.nextU8();
    let isVarArgMask = reader.nextU8();
    let maxStackSize = reader.nextU8();

    // PADDING
    reader.nextU32();
    return null;
  }

  _processTable(reader, ptr, allocStr) {
    let flags = reader.nextU8();
    let lsizenode = reader.nextU8();
    let metaTablePtr = reader.nextPtr();

    // PADDING
    reader.nextU32();
    let arrayPtr = reader.nextPtr();
    let node = reader.nextPtr();
    let lastFree = reader.nextPtr();
    let gclist = reader.nextPtr();
    let sizeArray = reader.nextU32();

    // PADDING
    reader.nextU32();

    let result = new TableHeapObject(ptr, allocStr, metaTablePtr, arrayPtr, node);

    this._addToBackmap(arrayPtr.low, result);
    this._addToBackmap(node.low, result);
    return result;
  }

  _processArray(ptr, allocStr, bytes) {
    let numBytes = bytes.byteLength;
    let reader = new ArrayReader(bytes.buffer, bytes.byteOffset); 

    console.assert((numBytes % 16) == 0);

    var entries = [];
    var stringFieldNames = [];
    let result = new ArrayHeapObject(ptr, allocStr, entries, stringFieldNames);
    for (var i = 0; i < numBytes / 16; i++) {
      let val = reader.nextPtr();
      let valType = reader.nextU32();
      reader.nextU32();

      if (valType >= 5 && valType <= 7) {
        entries.push(val);
        this._addToBackmap(val.low, result);
      }
    }
    return result;
  }

  _processMap(ptr, allocStr, bytes) {
    let numBytes = bytes.byteLength;
    let reader = new ArrayReader(bytes.buffer, bytes.byteOffset); 

    console.assert((numBytes % 40) == 0);

    var entries = [];
    var stringFieldNames = [];
    let result = new ArrayHeapObject(ptr, allocStr, entries, stringFieldNames);
    for (var i = 0; i < numBytes / 40; i++) {
      let val = reader.nextPtr();
      let valType = reader.nextU32();
      reader.nextU32();

      if (valType >= 5 && valType <= 7) {
        entries.push(val);
        this._addToBackmap(val.low, result);
      }

      let key = reader.nextPtr();
      let keyType = reader.nextU32();
      reader.nextU32();
      if (keyType >= 5 && keyType <= 7) {
        entries.push(key);
        this._addToBackmap(key.low, result);
      } else if (keyType == '4') {
        var str = this.heapObjs[key.low];
        if (str) {
          stringFieldNames.push(str.toString());
        }
      }
      // Ignore 'next' ptr.
      reader.nextPtr();
    }
    return result;
  }

  _processUserData(reader, numBytes, ptr, allocStr) {
    reader.skip(6);
    let metatable = reader.nextPtr();
    let env = reader.nextPtr();
    let len = reader.nextU32();
    reader.nextU32();  // len is a size_t!
    
    // The user bytes.
    reader.skip(len);

    // Any padding ((8 + 1 + 1) + 26).  This might be unnecessary.
    reader.skip(numBytes - (40 + len));

    return new UserDataHeapObject(ptr, allocStr, metatable);
  }

  _processUpValue(reader, ptr, allocStr) {
    // PADDING.
    reader.nextU32();
    reader.nextU8();
    reader.nextU8();

    let valPtr = reader.nextPtr();
    let result = new UpValueHeapObject(ptr, allocStr, valPtr);
    
    this._addToBackmap(valPtr.low, result);

    // Fixme: NASTY UNIONS
    let val = reader.nextPtr();
    let next = reader.nextPtr();

    // No idea if this is sufficient....
    return result;
  }

  _processString(reader, ptr, allocStr) {
    let reserved = reader.nextU8();
    let hash = reader.nextU32();

    // PADDING
    reader.nextU8();
    let size = reader.nextU32(); reader.nextU32(); // size_t
    let str = reader.nextStr();

    return new StringHeapObject(ptr, allocStr, str);
  }

  _processObject(reader) {
    let strIdx = reader.nextU32();
    let str = this.strs[strIdx];

    let ptr = reader.nextPtr();

    let numBytes = reader.nextU32();
    reader.nextU32();

    var typ = reader.peekByte(8);
    if (typ >= 0 && typ <= 10 && reader.peekPtr().looksValid()) {

      let gcNext = reader.nextPtr(); 

      typ = reader.nextU8();

      let marked = reader.nextU8();

      //console.log('type: ' + typ + '.  size: ' + numBytes + '. loc: ' + (reader.getOffset() - 10));

      if (marked == 0) {
        // A good question might be to ask: if we call FullGC before dumping the heap, then what the
        // heck is this stuff doing here?
        //console.log('marked = 0');
        reader.skip(numBytes - 10);
        return;
      }

      var obj = null;
      switch(typ) {
        case 0:
          //NIL
          reader.skip(numBytes - 10);
          break;
        case 1:
          //BOOL
          reader.skip(numBytes - 10);
          break;
        case 2:
          // 'light' user data.  huh?
          console.assert(false);
          break;
        case 3:
          // number
          reader.skip(numBytes - 10);
          break;
        case 4:
          // string
          obj = this._processString(reader, ptr.low, str);
          break;
        case 5:
          // table
          console.assert(numBytes == 64);
          obj = this._processTable(reader, ptr.low, str);
          this.tableObjs[ptr.low] = obj;
          break;
        case 6:
          // A closure of some kind
          obj = this._processClosure(reader, ptr.low, str);
          break;
        case 7:
          // user data
          obj = this._processUserData(reader, numBytes, ptr.low, str);
          break;
        case 8:
          // thread
          reader.skip(numBytes - 10);
          break;    
        case 9:
          // Function prototype
          console.assert(numBytes == 120);
          this._processFuncPrototype(reader, ptr.low, str);
          break;

        case 10:
          // up value
          obj = this._processUpValue(reader, ptr.low, str);
          break;

        default:
          console.log('unknown type: ' + typ + ' at ' + reader.getOffset());
          reader.skip(numBytes - 10);
          break;
      };
    } else {
      this.unknownObjs[ptr.low] = new UnknownHeapObject(ptr.low, str, reader.readBytes(numBytes));
    }

    if (obj) {
      this.heapObjs[ptr.low] = obj;
    }
  }

  _processAllocs(reader) {
    let numAllocs = reader.nextU32();

    for (var i = 0; i < numAllocs; i++) {
      this._processObject(reader);
    }

    this._attachArrays();

    for (var k in this.heapObjs) {
      var obj = this.heapObjs[k];
      var objs = this.allocIdxToObjs[obj.allocStr];

      if (!objs) {
        objs = [];
        this.allocIdxToObjs[obj.allocStr] = objs;
      }

      objs.push(obj);
    }
  }

  _attachArrays() {
    for (var k in this.tableObjs) {
      var ptr = this.tableObjs[k].getArrayPtr().low;
      if (ptr) {
        var arrObj = this.unknownObjs[ptr];
        if (arrObj) {
          this.heapObjs[ptr] = this._processArray(ptr, arrObj.allocStr, arrObj.bytes);
        }
      }

      ptr = this.tableObjs[k].getNodePtr().low;
      if (ptr) {
        var arrObj = this.unknownObjs[ptr];
        if (arrObj) {
          this.heapObjs[ptr] = this._processMap(ptr, arrObj.allocStr, arrObj.bytes);
        }
      }
    }
  }
}

class HeapExpApplication extends React.Component {

  constructor(props) {
    super(props);

    this.heaps = [];

    this.state = {
      allocIdxToObjs: {}, 
      objs:{}, 
      strsToIdx:{},
      backMap:{},
      diffStrsToIdx:{}
    };
  }

  _processHeapDump(diffHeap) {
    this.setState({
      idxToObjs : diffHeap.allocIdxToObjs,
      objs : diffHeap.heapObjs,
      strsToIdx : diffHeap.strsToIdx,
      backMap : diffHeap.backMap,
      diffObjs : diffHeap.diffObjs,
      diffStrsToIdx : diffHeap.diffStrsToIdx
    });
  }

  componentDidMount() {
    let handleFileSelect = (evt) => {
      for (var i = 0; i < 2; i++) {
        let reader = new FileReader();
        reader.onload = (e) => {
          this.heaps.push(new Heap(e.target.result));
          if (this.heaps.length == 2) {
            this._processHeapDump(this.heaps[0].diff(this.heaps[1]));
          }
        };
        reader.readAsArrayBuffer(evt.target.files[i])
      }
    };
    document.getElementById('files').addEventListener('change', handleFileSelect, false);    
  }

  render() {
    return (
      <HeapRows strs={this.state.strs} idxToObjs={this.state.idxToObjs} objs={this.state.objs} strsToIdx={this.state.strsToIdx} backMap={this.state.backMap} diffStrsToIdx={this.state.diffStrsToIdx} />
    );
  }
}


React.render(
  <HeapExpApplication  />,
  document.getElementById('container')
);

    </script>
  </body>
</html>
