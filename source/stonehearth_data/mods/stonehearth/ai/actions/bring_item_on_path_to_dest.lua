--[[
   Use this compound action when you already have a path to the object
   you want to pick up (as might be generated by say, a worker scheduler.)
   Pick up the item at that point and then path to the target destination.
]]
local BringItemOnPathToDest = class()

BringItemOnPathToDest.name = 'bring item on path to dest'
BringItemOnPathToDest.does = 'stonehearth:bring_item_on_path_to_dest'
BringItemOnPathToDest.priority = 5

function BringItemOnPathToDest:__init(ai, entity)
   self._entity = entity
   self._ai = ai

   self._path_to_destination = nil
   self._temp_entity = nil
   self._ghost_entity = nil
   self._pathfinder = nil
end

--- Pick up and place the item designated by the caller
-- @param path The path to the object
-- @ghost_entity The object representing the destination
-- @param rotation The degree at which the object should appear when it's placed
-- @on_terrain True if we want to put the object on the terrain, false if we want to put the object in the ghost entity
function BringItemOnPathToDest:run(ai, entity, path, ghost_entity, rotation, on_terrain)
   local proxy_entity = path:get_destination()
   -- We already have a path to the object, so set up a pathfinder
   -- between the object and its final destination, to use later.
   self._ghost_entity = ghost_entity
   self:_find_path_to_ghost_item(proxy_entity)
   ai:execute('stonehearth:pickup_item_on_path', path)

   -- If we're here, pickup succeeded, so we're now carrying the item.
   -- Wait until the PF we started earlier returns
   assert(proxy_entity:get_id() == radiant.entities.get_carrying(entity):get_id())
   ai:wait_until(function()
      return self._path_to_destination ~= nil
   end)
   ai:execute('stonehearth:follow_path', self._path_to_destination)
   if on_terrain then
      ai:execute('stonehearth:drop_carrying', self._path_to_destination:get_destination_point_of_interest())
   else
      ai:execute('stonehearth:drop_carrying_on_entity', self._ghost_entity)
   end
   radiant.entities.turn_to(proxy_entity, rotation)
end

--- Make a pathfinder between the target item and the final destination
-- Since the pf can only path between 2 entities, and since the target_item may be
-- picked up by the worker before the pf returns, create a temporary entity to serve
-- as the starting destiantion and the final destination
-- @param target_item the item that the worker is planning to pick up
function BringItemOnPathToDest:_find_path_to_ghost_item(target_item)
   local target_item_loc = target_item:get_component('mob'):get_world_grid_location()
   self._temp_entity = radiant.entities.create_entity()
   radiant.terrain.place_entity(self._temp_entity, target_item_loc)

   --When the path is solved, save the path so we can get it elsewhere
   local solved_cb = function(path)
      self._path_to_destination = path
   end

   local desc = string.format('finding a path from %s to a target location', tostring(target_item))
   self._pathfinder = radiant.pathfinder.create_path_finder(desc)
                        :set_source(self._temp_entity)
                        :add_destination(self._ghost_entity)
                        :set_solved_cb(solved_cb)
end

--- Destroy the temporary entities created for the pathfinder
function BringItemOnPathToDest:_destroy_temp_entities()
   if self._pathfinder then
      self._pathfinder:stop()
      self._pathfinder = nil
   end
   self._path_to_destination = nil

   if self._temp_entity then
      -- Remove the intermediate entity
      radiant.entities.destroy_entity(self._temp_entity)
   end
end

function BringItemOnPathToDest:stop()
   self:_destroy_temp_entities()
end

return BringItemOnPathToDest
