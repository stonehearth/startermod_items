#include "pch.h"
<%
if C._no_lua:
   return

import ridl.ridl as ridl
import ridl.dm_types as dm
class_upper = C.__name__
class_lower = env.lower(class_upper)
is_component = C.__bases__[0]().name == 'Component' 
trace_includes = []
for name, obj in env.properties(C, [dm.Boxed, dm.Set, dm.Array, dm.Map]):
   if obj.trace:
      if obj.trace == 'deep_region':
         trace_includes += [ "om/region.h" ]
      else:
         trace_includes += [
            "dm/%s.h" % obj.short_name,
            "dm/%s_trace.h" % obj.short_name
         ]
%>
#include "radiant.h"
#include "lib/lua/bind.h"
#include "lib/lua/register.h"
#include "lib/lua/script_host.h"
#include "lib/lua/dm/boxed_trace_wrapper.h"
#include "lib/lua/dm/map_iterator.h"
#include "lib/lua/dm/map_trace_wrapper.h"
#include "lib/lua/dm/set_iterator.h"
#include "lib/lua/dm/set_trace_wrapper.h"
% for filename in trace_includes:
#include "${filename}"
% endfor
#include "dm/trace_categories.h"
% for f in C._lua_includes:
#include "${f}"
% endfor
#include "om/components/${ class_lower }.ridl.h"

using namespace luabind;
using namespace radiant;
using namespace radiant::om;

static std::ostream& operator<<(std::ostream& os, std::weak_ptr<${class_upper}> o)
{
   auto object = o.lock();
   if (object) {
      os << *object;
   } else {
      os << "[invalid ${class_lower} reference]";
   }
   return os;
}

% if is_component:
static std::weak_ptr<${class_upper}> ${class_upper}_ExtendObject(lua_State* L, std::weak_ptr<${class_upper}> o, object obj)
{
   auto object = o.lock();
   if (object)  {
      object->ExtendObject(lua::ScriptHost::LuaToJson(L, obj));
      return o;
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::extend");
}
% endif

## - Boxed -----------------------------------------------------------------------------------
% for name, boxed in env.properties(C, dm.Boxed):
   % if boxed.get:
static ${boxed.value.name} ${class_upper}_Get${name | env.upper}(std::weak_ptr<${class_upper}> const o)
{
   auto object = o.lock();
   if (object)  {
      return object->Get${name | env.upper}();
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::get_${name}");
}

   % endif
   % if boxed.set:
static std::weak_ptr<${class_upper}> ${class_upper}_Set${name | env.upper}(std::weak_ptr<${class_upper}> o, ${boxed.value.name} value)
{
   auto object = o.lock();
   if (object)  {
      object->Set${name | env.upper}(value);
      return o;
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::set_${name}");
}

   % endif
% endfor

## - Set -----------------------------------------------------------------------------------
% for name, set in env.properties(C, dm.Set):
   <% singular_name = hasattr(set, 'singular_name') and set.singular_name or name %>
   % if set.add:
static std::weak_ptr<${class_upper}> ${class_upper}_Add${singular_name | env.upper}(std::weak_ptr<${class_upper}> const o, ${set.accessor_value.name} value)
{
   auto object = o.lock();
   if (object)  {
      object->Add${singular_name | env.upper}(value);
      return o;
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::add_${singular_name}");
}

   % endif
   % if set.remove:
static std::weak_ptr<${class_upper}> ${class_upper}_Remove${singular_name | env.upper}(std::weak_ptr<${class_upper}> o, ${set.accessor_value.name} value)
{
   auto object = o.lock();
   if (object)  {
      object->Remove${singular_name | env.upper}(value);
      return o;
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::remove_${singular_name}");
}

   % endif
   % if set.num:
static int ${class_upper}_Num${name | env.upper}(std::weak_ptr<${class_upper}> o)
{
   auto object = o.lock();
   if (object)  {
      return object->Num${name | env.upper}();
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::num_${name}");
}

   % endif
   % if set.iterate:
static std::shared_ptr<lua::SetIterator<${set.name}>> ${class_upper}_Each${singular_name | env.upper}(std::weak_ptr<${class_upper}> o)
{
   auto object = o.lock();
   if (object)  {
      return std::make_shared<lua::SetIterator<${set.name}>>(object->Each${singular_name | env.upper}());
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::each_${singular_name}");
}
   % endif
% endfor

## - Map -----------------------------------------------------------------------------------
% for name, map in env.properties(C, dm.Map):
   <% singular_name = hasattr(map, 'singular_name') and map.singular_name or name %>
   % if map.add:
static std::weak_ptr<${class_upper}> ${class_upper}_Add${singular_name | env.upper}(std::weak_ptr<${class_upper}> const o, ${map.key.name} key, ${map.accessor_value.name} value)
{
   auto object = o.lock();
   if (object)  {
      object->Add${singular_name | env.upper}(key, value);
      return o;
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::add_${singular_name}");
}

   % endif
   % if map.remove:
static std::weak_ptr<${class_upper}> ${class_upper}_Remove${singular_name | env.upper}(std::weak_ptr<${class_upper}> o, ${map.key.name} key)
{
   auto object = o.lock();
   if (object)  {
      object->Remove${singular_name | env.upper}(key);
      return o;
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::remove_${singular_name}");
}

   % endif
   % if map.get:
static ${map.accessor_value.name} ${class_upper}_Get${singular_name | env.upper}(std::weak_ptr<${class_upper}> o, ${map.key.name} key)
{
   auto object = o.lock();
   if (object)  {
      return object->Get${singular_name | env.upper}(key);
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::get_${singular_name}");
}

   % endif
   % if map.iterate:
static void ${class_upper}_Each${singular_name | env.upper}(lua_State *L, std::weak_ptr<${class_upper}> o)
{
   auto obj = o.lock();
   if (obj)  {
      typedef lua::MapIterator<${map.name}> Iterator;
      lua_pushcfunction(L, Iterator::NextIteration);                              // f
      object(L, new Iterator(obj->Each${singular_name | env.upper}())).push(L); // s
      object(L, 1).push(L);                                                       // var (ignored)
      return;
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::each_${singular_name}");
}
   % endif
   % if map.num:
static int ${class_upper}_Num${name | env.upper}(std::weak_ptr<${class_upper}> o)
{
   auto object = o.lock();
   if (object)  {
      return object->Num${name | env.upper}();
   }
   throw std::invalid_argument("invalid reference in native num");
}
   % endif

% endfor

## - Methods -----------------------------------------------------------------------------------
% for method_name, method in env.properties(C, ridl.Method):
<% 
   formal_params = 'std::weak_ptr<%s> o' % class_upper
   additional_params = method.formal_params
   if len(additional_params) > 0:
      formal_params += ', ' + additional_params
%>
%   if method.result.name == 'void':
std::weak_ptr<${class_upper}> ${class_upper}_${method_name | env.upper}(${formal_params})
{
   std::shared_ptr<${class_upper}> ${class_lower} = o.lock();
   if (${class_lower}) {
      ${class_lower}->${method_name | env.upper}(${method.actual_params});
      return o;
   }
   throw std::invalid_argument("invalid reference in ${class_lower}::${method_name}");
}
%   else:
${method.result.name} ${class_upper}_${method_name | env.upper}(${formal_params})
{
   std::shared_ptr<${class_upper}> ${class_lower} = o.lock();
   if (${class_lower}) {
      return ${class_lower}->${method_name | env.upper}(${method.actual_params});
   }
   throw std::invalid_argument("invalid reference in ${class_lower}::${method_name}");
}
%   endif
% endfor

## - All Traces-----------------------------------------------------------------------------------
% for name, obj in env.properties(C, [dm.Boxed, dm.Set, dm.Array, dm.Map]):
   % if obj.trace:
      % if obj.trace == 'deep_region':
static std::shared_ptr<lua::${obj.short_name | env.upper}TraceWrapper<DeepRegionGuard>>
${class_upper}_Trace${name | env.upper}(std::weak_ptr<${class_upper}> o, const char* reason)
{
   auto object = o.lock(); 
   if (object)  {
      auto trace = object->Trace${name | env.upper}(reason, dm::LUA_TRACES);
      return std::make_shared<lua::${obj.short_name | env.upper}TraceWrapper<DeepRegionGuard>>(trace);
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::trace_${name}");
}
      % else:
static std::shared_ptr<lua::${obj.short_name | env.upper}TraceWrapper<${obj.trace_name}>>
${class_upper}_Trace${name | env.upper}(std::weak_ptr<${class_upper}> o, const char* reason)
{
   auto object = o.lock(); 
   if (object)  {
      auto trace = object->Trace${name | env.upper}(reason, dm::LUA_TRACES);
      return std::make_shared<lua::${obj.short_name | env.upper}TraceWrapper<${obj.trace_name}>>(trace);
   }
   throw std::invalid_argument("invalid reference in native ${class_lower}::trace_${name}");
}
      % endif
   % endif
% endfor

scope Register${class_upper}(lua_State* L)
{
   return
%if is_component:
      lua::RegisterWeakGameObjectDerived<${class_upper}, ${C.__bases__[0]().name}>()
%elif C._lua_weak_ref:
      lua::RegisterWeakGameObject<${class_upper}>()
%else:
      lua::RegisterStrongGameObject<${class_upper}>()
%endif
## - Enum -----------------------------------------------------------------------------------
% for name, enum in env.properties(C, ridl.Enum):
   <% count = len(enum.values) - 1 %>
         .enum_("${enum.internal_name}") [
%   for i in xrange(count):
            value("${enum.values[i][0] | env.caps}",  ${class_upper}::${enum.values[i][0]}),
%   endfor
            value("${enum.values[count][0] | env.caps}",  ${class_upper}::${enum.values[count][0]})
         ]
% endfor
% if is_component:
         .def("extend",                &${class_upper}_ExtendObject)
% endif
## - Boxed -----------------------------------------------------------------------------------
% for name, boxed in env.properties(C, dm.Boxed):
   % if boxed.get:
         .def("get_${name | env.lower}", ${class_upper}_Get${name | env.upper})
   % endif
   % if boxed.set:
         .def("set_${name | env.lower}", ${class_upper}_Set${name | env.upper})
   % endif
% endfor
## - Set -----------------------------------------------------------------------------------
% for name, set in env.properties(C, dm.Set):
   <% singular_name = hasattr(set, 'singular_name') and set.singular_name or name %>
   % if set.add:
         .def("add_${singular_name | env.lower}", ${class_upper}_Add${singular_name | env.upper})
   % endif
   % if set.remove:
         .def("remove_${singular_name | env.lower}", ${class_upper}_Remove${singular_name | env.upper})
   % endif
   % if set.iterate:
         .def("each_${singular_name | env.lower}", ${class_upper}_Each${singular_name | env.upper})
   % endif
   % if set.num:
         .def("num_${name | env.lower}", ${class_upper}_Num${name | env.upper})
   % endif
% endfor
## - Map -----------------------------------------------------------------------------------
% for name, map in env.properties(C, dm.Map):
   <% singular_name = hasattr(map, 'singular_name') and map.singular_name or name %>
   % if map.add:
         .def("add_${singular_name | env.lower}", ${class_upper}_Add${singular_name | env.upper})
   % endif
   % if map.remove:
         .def("remove_${singular_name | env.lower}", ${class_upper}_Remove${singular_name | env.upper})
   % endif
   % if map.get:
         .def("get_${singular_name | env.lower}", ${class_upper}_Get${singular_name | env.upper})
   % endif
   % if map.iterate:
         .def("each_${singular_name | env.lower}", ${class_upper}_Each${singular_name | env.upper})
   % endif
   % if map.num:
         .def("num_${name | env.lower}", ${class_upper}_Num${name | env.upper})
   % endif
% endfor
## - All Traces ------------------------------------------------------------------------------
% for name, set in env.properties(C, [dm.Set, dm.Map, dm.Boxed, dm.Array]):
   % if set.trace:
         .def("trace_${name | env.lower}", ${class_upper}_Trace${name | env.upper})
   % endif
% endfor
## - Methods -----------------------------------------------------------------------------------
% for method_name, method in env.properties(C, ridl.Method):
         .def("${method_name | env.lower}", &${class_upper}_${method_name | env.upper})
% endfor
      ;
}
